/* gf256.c - GF(2^8) 유한체 연산 구현 */
#include <stdint.h>
#include "../include/gf256.h"

/* =============================================================================
 * 상수 정의
 * ============================================================================= */

#define GF256_SIZE 256      /* GF(2^8) 크기 (2^8 = 256) */
#define GF256_POLY 0x1b     /* 기약다항식: x^8 + x^4 + x^3 + x + 1 = 0x11b */
#define GF256_MSB 0x80      /* 최상위 비트 마스크 */

/* =============================================================================
 * GF(2^8) 역원 테이블
 * ============================================================================= */

/**
 * @brief GF(2^8) 역원 테이블
 * 
 * 미리 계산된 역원 테이블로, 빠른 역원 계산을 위해 사용됩니다.
 * gf256_inv_table[a] = a^(-1) in GF(2^8)
 * 
 * 특별한 경우:
 * - gf256_inv_table[0] = 0 (0의 역원은 정의되지 않음)
 * - gf256_inv_table[1] = 1 (1의 역원은 자기 자신)
 */
static const uint8_t gf256_inv_table[GF256_SIZE] = {
    /* 0x00-0x0F */
    0x00, 0x01, 0x8d, 0xf6, 0xcb, 0x52, 0x7b, 0xd1, 0xe8, 0x4f, 0x29, 0xc0, 0xb0, 0xe1, 0xe5, 0xc7,
    /* 0x10-0x1F */
    0x74, 0xb4, 0xaa, 0x4b, 0x99, 0x2b, 0x60, 0x5f, 0x58, 0x9f, 0xa6, 0x03, 0xba, 0xca, 0x45, 0xef,
    /* 0x20-0x2F */
    0xac, 0x73, 0x8c, 0x51, 0xcd, 0x62, 0xe3, 0x5e, 0x4a, 0x9e, 0x95, 0x02, 0x7a, 0x9c, 0x56, 0x8f,
    /* 0x30-0x3F */
    0xea, 0x15, 0x3f, 0x07, 0x5b, 0x01, 0x5c, 0x9a, 0x87, 0x12, 0x80, 0xe0, 0x19, 0x4b, 0xd2, 0x7e,
    /* 0x40-0x4F */
    0x3a, 0x6b, 0x94, 0x98, 0x88, 0x50, 0x2e, 0x4d, 0x4c, 0xf8, 0x20, 0x3d, 0x5d, 0x9d, 0x7c, 0x64,
    /* 0x50-0x5F */
    0x71, 0x87, 0x96, 0xab, 0x8b, 0x1f, 0x77, 0xc3, 0x58, 0x2b, 0x3f, 0x7a, 0x8c, 0x02, 0x64, 0x01,
    /* 0x60-0x6F */
    0x8f, 0x5c, 0xca, 0x4e, 0x24, 0x02, 0x42, 0x95, 0x5c, 0x5a, 0x07, 0x7b, 0x0e, 0x76, 0x07, 0x19,
    /* 0x70-0x7F */
    0x38, 0x25, 0x4f, 0x40, 0x2d, 0x3a, 0xcf, 0x73, 0x2f, 0xed, 0xcc, 0x99, 0x24, 0x5c, 0x9e, 0xee,
    /* 0x80-0x8F */
    0x5a, 0xee, 0x21, 0x67, 0x69, 0x36, 0x9e, 0x5f, 0x3b, 0x07, 0x75, 0x97, 0x35, 0x44, 0x58, 0x89,
    /* 0x90-0x9F */
    0x0b, 0x90, 0x27, 0x04, 0x06, 0x50, 0x14, 0x73, 0x0a, 0x23, 0x4e, 0x71, 0x5c, 0x80, 0x22, 0x36,
    /* 0xA0-0xAF */
    0x0c, 0x5f, 0x03, 0x1d, 0x21, 0x25, 0x26, 0x04, 0x1c, 0x5a, 0x04, 0x68, 0x73, 0x0f, 0x77, 0x06,
    /* 0xB0-0xBF */
    0x07, 0x31, 0x92, 0x41, 0x20, 0x10, 0x11, 0x5d, 0x9a, 0x48, 0x96, 0x2c, 0xbc, 0x8c, 0x04, 0x18,
    /* 0xC0-0xCF */
    0x44, 0x63, 0x2c, 0x49, 0xaa, 0x2e, 0x4e, 0xea, 0x2b, 0x22, 0x68, 0x7a, 0x31, 0x2b, 0xaa, 0x6a,
    /* 0xD0-0xDF */
    0x88, 0x2a, 0xac, 0x68, 0x11, 0x98, 0x99, 0x6b, 0x58, 0x91, 0x93, 0x41, 0x20, 0x9f, 0x4e, 0xb2,
    /* 0xE0-0xEF */
    0x4a, 0x73, 0x6a, 0xad, 0x72, 0x90, 0xaf, 0x39, 0x4c, 0x2d, 0x36, 0x1b, 0x25, 0x21, 0x5f, 0x4a,
    /* 0xF0-0xFF */
    0x4e, 0x18, 0x2a, 0x50, 0x4f, 0xaa, 0x5f, 0x06, 0x1c, 0x2c, 0xbc, 0x1b, 0x24, 0x07, 0x04, 0x0f
};

/* =============================================================================
 * 내부 헬퍼 함수들
 * ============================================================================= */

/**
 * @brief 기약다항식으로 모듈로 감소
 * @param value 감소시킬 값
 * @return 모듈로 감소된 값
 */
static uint8_t gf256_reduce(uint8_t value)
{
    // x^8 = x^4 + x^3 + x + 1 (mod GF256_POLY)
    // 따라서 x^8을 만나면 0x1b를 XOR
    return (value & GF256_MSB) ? (value << 1) ^ GF256_POLY : (value << 1);
}

/* =============================================================================
 * 공개 API 함수들
 * ============================================================================= */

/**
 * @brief GF(2^8)에서 x 곱하기 (0x02 곱하기)
 * 
 * 이는 AES MixColumns에서 자주 사용되는 연산입니다.
 * x 곱하기는 왼쪽 시프트 후 기약다항식으로 모듈로 감소하는 것입니다.
 * 
 * @param a 곱할 값
 * @return a * x in GF(2^8)
 */
uint8_t gf256_mul2(uint8_t a)
{
    return gf256_reduce(a);
}

/**
 * @brief GF(2^8)에서 x^2 곱하기 (0x04 곱하기)
 * 
 * x^2 곱하기는 x 곱하기를 두 번 적용하는 것입니다.
 * 
 * @param a 곱할 값
 * @return a * x^2 in GF(2^8)
 */
uint8_t gf256_mul4(uint8_t a)
{
    return gf256_mul2(gf256_mul2(a));
}

/**
 * @brief GF(2^8)에서 x^3 곱하기 (0x08 곱하기)
 * 
 * x^3 곱하기는 x^2 곱하기 후 x 곱하기를 적용하는 것입니다.
 * 
 * @param a 곱할 값
 * @return a * x^3 in GF(2^8)
 */
uint8_t gf256_mul8(uint8_t a)
{
    return gf256_mul2(gf256_mul4(a));
}

/**
 * @brief GF(2^8)에서 3 곱하기 (0x03 곱하기)
 * 
 * 3 = 2 + 1이므로, x 곱하기와 원래 값을 XOR합니다.
 * 이는 AES MixColumns에서 자주 사용됩니다.
 * 
 * @param a 곱할 값
 * @return a * 3 in GF(2^8)
 */
uint8_t gf256_mul3(uint8_t a)
{
    return gf256_mul2(a) ^ a;
}

/**
 * @brief GF(2^8)에서 일반적인 곱셈
 * 
 * 이진 곱셈 알고리즘을 사용하여 두 값을 곱합니다.
 * 이는 모든 GF(2^8) 곱셈의 기본이 되는 함수입니다.
 * 
 * @param a 첫 번째 피연산자
 * @param b 두 번째 피연산자
 * @return a * b in GF(2^8)
 */
uint8_t gf256_mul(uint8_t a, uint8_t b)
{
    uint8_t result = 0;
    
    // 이진 곱셈 알고리즘
    while (b != 0) {
        // b의 최하위 비트가 1이면 a를 결과에 더함 (XOR)
        if (b & 1) {
            result ^= a;
        }
        
        // a를 x 곱하기 (왼쪽 시프트 후 모듈로 감소)
        uint8_t carry = a & GF256_MSB;
        a <<= 1;
        if (carry) {
            a ^= GF256_POLY;
        }
        
        // b를 오른쪽으로 시프트
        b >>= 1;
    }
    
    return result;
}

/**
 * @brief GF(2^8)에서 역원 계산
 * 
 * 테이블 룩업을 사용하여 빠르게 역원을 계산합니다.
 * 0의 역원은 정의되지 않으므로 0을 반환합니다.
 * 
 * @note 현재 코드베이스에서는 이 함수가 사용되지 않습니다.
 *       향후 확장성(InvMixColumns 일반화, S-Box 생성 등)을 위해 미리 구현해둔 함수입니다.
 * 
 * @param a 역원을 구할 값
 * @return a^(-1) in GF(2^8), a가 0이면 0
 */
uint8_t gf256_inv(uint8_t a)
{
    return gf256_inv_table[a];
}

/**
 * @brief GF(2^8)에서 제곱
 * 
 * 제곱은 곱셈의 특별한 경우로, 같은 값을 곱하는 것입니다.
 * 
 * @param a 제곱할 값
 * @return a^2 in GF(2^8)
 */
uint8_t gf256_square(uint8_t a)
{
    return gf256_mul(a, a);
}

/**
 * @brief GF(2^8)에서 제곱근
 * 
 * GF(2^8)에서 제곱근은 a^(128)과 같습니다.
 * 이는 7번의 제곱 연산으로 계산할 수 있습니다.
 * 
 * @param a 제곱근을 구할 값
 * @return sqrt(a) in GF(2^8)
 */
uint8_t gf256_sqrt(uint8_t a)
{
    uint8_t result = a;
    
    // a^(128) = sqrt(a) in GF(2^8)
    // 128 = 2^7이므로 7번의 제곱 연산
    for (int i = 0; i < 7; i++) {
        result = gf256_square(result);
    }
    
    return result;
}